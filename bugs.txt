
3/19, Sudo Make Exception
    E: make dep works, but sudo make gives error saying "./debug.sh does not exist"
    F: Ran command "dos2unix debug.sh" and rebooted vm and compiled fine.

3/19, Error: no such instruction 
    E: All functions defined in idt.h file have error "no such instruction"
    F: Wrapped function header portion of file in "#ifndef ASM" then "define ASM 1", and "endif" at end

3/19, "Warning: initializer-string for any array of chars is too long"
    E: Repeated error in idt.c file, but array declaration seems fine 
    F: Bounds of array were flipped

3/19, Exception_Linkage.S compilation error 
    E: After running sudo make, keep getting error "no such instruction." in Exception_Linkage.S. Diff from " Error: no such instruction" 
    F: Included "Exception_Linkage.h" inside Exception_Linkage.S file, but errors gone once removed.

3/19, Test case does not get reached 
    E: Test case is not even called, but something works when function call for init_idt  is commented out.
    F: Was not updating seg_selector of each idt. For each idt from 0 to 255, set seg_selector to KERNEL_CS using: idt[i].seg_selector = KERNEL_CS;

3/20, Print for division error test case not even shown 
    E: There is no indication on the screen that the test case was failed, and a /0 error has happened.
    F: Added a while(1) loop after print, so that the error message is hard coded to screen.

3/20, When page is initalized, division error was not working 
    E: Narrowed it down to assembly in pagingasm.S, something wrong with cr0 maybe
    F: Set page table addr to 0xb8 instead of 0 and it worked

3/20, Cannot see 2 allocated memories when using info mem 
    E: Issue is likely with offsets in pagingasm.S.
    F: Offset for OR cr0 is should be 0x80000001 not 0x80000000;

3/20,
    The first bug was in initializing the PIC. The incorrect implementation would cause the program to crash. This was fixed
    by allowing interrups after they were masked for initializing

3/21,
    The second bug was in the keyboard interrupt handler when masking was used. The mask was sent to the slave pic by accident.
    This was fixed by updating the address for the output 

3/21,
    This bug occured because the keyboard would print the pressed and depressed outputs. This was fixed by adding a range check
    to ensure that only presses are printed

3/24,
    E: RTC read not allowing for read. After GDB, did not get to end
    F: Did not need the if statement before. More importantly, did not set interrupt flag to 0. 
    This is because you are interrupting when doing RTC read, so you can clear interrupt flag.

3/24,
    E: rtc_open and rtc_write not setting frequency, not sure what issue is
    F: cli() and sti() are in the wrong order lol

3/25,
    E: Getting a "not checking for void pointer bug" in rtc.c in rtc_write
    F: Added a conditional to test if given buffer has is void if dereferenced

3/24,
    E: Issue with figuring out indexing of data block vs actual data
    F: Since each data block has 4096 bytes, I iterated through each byte to read and indexed the inode using I / 4096 and each byte in a data block with I % 4096   

3/25,
    E: rtc_write does not set frequency for certain values of i
    F: Test case was iterating through all i from 0 t0 20, but the helper function rtc_logbase2 was not accounting for frequencies that were not multiples of two.

3/25,
    E: test case for rtc is not showing i each time rtc is called, and function header interferes with prints
    F: Moved the tests into rtc_handler by adding terminal_write(0,"123",3); to print 3

3/24,
    E: when the terminal is opened and text is printed off the edge it would overwrite its own section of text instead of the next line
    F: This was fixed by incermenting screen y by one everytime it reaches the end of a line and resets screen x to 0

3/25,
    E: Terminal read would read in all characters correctly except the first character
    F: This was fixed by replacing the new line char at the end to null so it can properly print all the chars from the line


3/26,
    E: Figure out how go through each file in a directory incrementally
    F:Had a global variable called file position which was incremented each time read was called to respectively go through each directory in the boot block

3/26,
    E: When reading from a file random characters were getting copied onto the screen
    F: Had to allocate additional space in the buffer to account for an end of string character as the character is needed to properly print a string to the screen

